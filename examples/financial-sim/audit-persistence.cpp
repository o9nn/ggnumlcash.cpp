#include "audit-persistence.h"
#include <algorithm>

namespace ggnucash {
namespace audit {

// ============================================================================
// AuditPersistenceAdapter Implementation
// ============================================================================

AuditPersistenceAdapter::AuditPersistenceAdapter() {}

// ---- Schema Management ----

std::string AuditPersistenceAdapter::generate_schema_sql() const {
    std::stringstream ss;

    ss << "-- GGNuCash Immutable Audit Trail Schema\n";
    ss << "-- Generated by AuditPersistenceAdapter\n";
    ss << "-- SOX Compliant: 7-year retention, tamper-evident\n\n";

    ss << "CREATE TABLE IF NOT EXISTS audit_entries (\n";
    ss << "    entry_id            VARCHAR(128) PRIMARY KEY,\n";
    ss << "    previous_entry_hash VARCHAR(64)  NOT NULL,\n";
    ss << "    entry_hash          VARCHAR(64)  NOT NULL,\n";
    ss << "    signature           VARCHAR(64)  NOT NULL,\n";
    ss << "    timestamp_iso8601   VARCHAR(32)  NOT NULL,\n";
    ss << "    severity            VARCHAR(16)  NOT NULL,\n";
    ss << "    category            VARCHAR(32)  NOT NULL,\n";
    ss << "    actor               VARCHAR(256) NOT NULL DEFAULT '',\n";
    ss << "    action              VARCHAR(256) NOT NULL DEFAULT '',\n";
    ss << "    resource            VARCHAR(512) NOT NULL DEFAULT '',\n";
    ss << "    details             TEXT         NOT NULL DEFAULT '',\n";
    ss << "    transaction_id      VARCHAR(128) DEFAULT '',\n";
    ss << "    transaction_hash    VARCHAR(64)  DEFAULT '',\n";
    ss << "    metadata_json       TEXT         DEFAULT '{}',\n";
    ss << "    created_at          TIMESTAMP    DEFAULT CURRENT_TIMESTAMP\n";
    ss << ");\n\n";

    ss << "CREATE INDEX IF NOT EXISTS idx_audit_timestamp\n";
    ss << "    ON audit_entries (timestamp_iso8601);\n\n";

    ss << "CREATE INDEX IF NOT EXISTS idx_audit_severity\n";
    ss << "    ON audit_entries (severity);\n\n";

    ss << "CREATE INDEX IF NOT EXISTS idx_audit_category\n";
    ss << "    ON audit_entries (category);\n\n";

    ss << "CREATE INDEX IF NOT EXISTS idx_audit_actor\n";
    ss << "    ON audit_entries (actor);\n\n";

    ss << "CREATE INDEX IF NOT EXISTS idx_audit_transaction_id\n";
    ss << "    ON audit_entries (transaction_id);\n\n";

    ss << "CREATE INDEX IF NOT EXISTS idx_audit_entry_hash\n";
    ss << "    ON audit_entries (entry_hash);\n";

    return ss.str();
}

// ---- Serialization ----

SerializedAuditEntry AuditPersistenceAdapter::serialize_entry(
    const SignedAuditEntry & entry) const {
    SerializedAuditEntry serialized;
    serialized.entry_id = entry.entry_id;
    serialized.previous_entry_hash = entry.previous_entry_hash;
    serialized.entry_hash = entry.entry_hash;
    serialized.signature = entry.signature;
    serialized.timestamp_iso8601 = entry.timestamp_iso8601;
    serialized.severity = severity_to_string(entry.severity);
    serialized.category = category_to_string(entry.category);
    serialized.actor = entry.actor;
    serialized.action = entry.action;
    serialized.resource = entry.resource;
    serialized.details = entry.details;
    serialized.transaction_id = entry.transaction_id;
    serialized.transaction_hash = entry.transaction_hash;
    serialized.metadata_json = serialize_metadata(entry.metadata);
    return serialized;
}

SignedAuditEntry AuditPersistenceAdapter::deserialize_entry(
    const SerializedAuditEntry & serialized) const {
    SignedAuditEntry entry;
    entry.entry_id = serialized.entry_id;
    entry.previous_entry_hash = serialized.previous_entry_hash;
    entry.entry_hash = serialized.entry_hash;
    entry.signature = serialized.signature;
    entry.timestamp_iso8601 = serialized.timestamp_iso8601;
    entry.severity = sql_to_severity(serialized.severity);
    entry.category = sql_to_category(serialized.category);
    entry.actor = serialized.actor;
    entry.action = serialized.action;
    entry.resource = serialized.resource;
    entry.details = serialized.details;
    entry.transaction_id = serialized.transaction_id;
    entry.transaction_hash = serialized.transaction_hash;
    entry.metadata = deserialize_metadata(serialized.metadata_json);

    // Parse timestamp from ISO 8601 string
    // Format: YYYY-MM-DDTHH:MM:SS.mmmZ
    std::tm tm = {};
    std::istringstream iss(serialized.timestamp_iso8601);
    iss >> std::get_time(&tm, "%Y-%m-%dT%H:%M:%S");
    if (!iss.fail()) {
        entry.timestamp = std::chrono::system_clock::from_time_t(
#ifdef _WIN32
            _mkgmtime(&tm)
#else
            timegm(&tm)
#endif
        );
    }

    return entry;
}

std::string AuditPersistenceAdapter::serialize_metadata(
    const std::map<std::string, std::string> & metadata) const {
    if (metadata.empty()) return "{}";

    std::stringstream ss;
    ss << "{";
    bool first = true;
    for (const auto & kv : metadata) {
        if (!first) ss << ", ";
        // Simple JSON serialization (escape quotes in values)
        ss << "\"" << kv.first << "\": \"";
        for (char c : kv.second) {
            if (c == '"') ss << "\\\"";
            else if (c == '\\') ss << "\\\\";
            else ss << c;
        }
        ss << "\"";
        first = false;
    }
    ss << "}";
    return ss.str();
}

std::map<std::string, std::string> AuditPersistenceAdapter::deserialize_metadata(
    const std::string & json) const {
    std::map<std::string, std::string> result;
    if (json.empty() || json == "{}") return result;

    // Simple JSON parsing for {"key": "value", ...} format
    size_t pos = 1; // Skip opening '{'
    while (pos < json.size()) {
        // Find key
        size_t key_start = json.find('"', pos);
        if (key_start == std::string::npos) break;
        size_t key_end = json.find('"', key_start + 1);
        if (key_end == std::string::npos) break;
        std::string key = json.substr(key_start + 1, key_end - key_start - 1);

        // Find value
        size_t val_start = json.find('"', key_end + 1);
        if (val_start == std::string::npos) break;

        // Parse value with escape handling
        std::string value;
        size_t i = val_start + 1;
        while (i < json.size()) {
            if (json[i] == '\\' && i + 1 < json.size()) {
                if (json[i + 1] == '"') { value += '"'; i += 2; }
                else if (json[i + 1] == '\\') { value += '\\'; i += 2; }
                else { value += json[i]; i++; }
            } else if (json[i] == '"') {
                break;
            } else {
                value += json[i];
                i++;
            }
        }

        result[key] = value;
        pos = i + 1;
    }

    return result;
}

// ---- Batch Operations ----

std::vector<SerializedAuditEntry> AuditPersistenceAdapter::serialize_batch(
    const std::vector<SignedAuditEntry> & entries) const {
    std::vector<SerializedAuditEntry> result;
    result.reserve(entries.size());
    for (const auto & entry : entries) {
        result.push_back(serialize_entry(entry));
    }
    return result;
}

std::string AuditPersistenceAdapter::generate_batch_insert_sql(
    const std::vector<SerializedAuditEntry> & entries) const {
    if (entries.empty()) return "";

    std::stringstream ss;
    ss << "INSERT INTO audit_entries (\n";
    ss << "    entry_id, previous_entry_hash, entry_hash, signature,\n";
    ss << "    timestamp_iso8601, severity, category, actor,\n";
    ss << "    action, resource, details, transaction_id,\n";
    ss << "    transaction_hash, metadata_json\n";
    ss << ") VALUES\n";

    for (size_t i = 0; i < entries.size(); i++) {
        const auto & e = entries[i];
        ss << "(";
        ss << "'" << escape_sql(e.entry_id) << "', ";
        ss << "'" << escape_sql(e.previous_entry_hash) << "', ";
        ss << "'" << escape_sql(e.entry_hash) << "', ";
        ss << "'" << escape_sql(e.signature) << "', ";
        ss << "'" << escape_sql(e.timestamp_iso8601) << "', ";
        ss << "'" << escape_sql(e.severity) << "', ";
        ss << "'" << escape_sql(e.category) << "', ";
        ss << "'" << escape_sql(e.actor) << "', ";
        ss << "'" << escape_sql(e.action) << "', ";
        ss << "'" << escape_sql(e.resource) << "', ";
        ss << "'" << escape_sql(e.details) << "', ";
        ss << "'" << escape_sql(e.transaction_id) << "', ";
        ss << "'" << escape_sql(e.transaction_hash) << "', ";
        ss << "'" << escape_sql(e.metadata_json) << "'";
        ss << ")";
        if (i < entries.size() - 1) ss << ",";
        ss << "\n";
    }
    ss << ";\n";

    return ss.str();
}

std::string AuditPersistenceAdapter::generate_query_sql(const AuditQuery & query) const {
    std::stringstream ss;
    ss << "SELECT entry_id, previous_entry_hash, entry_hash, signature,\n";
    ss << "       timestamp_iso8601, severity, category, actor,\n";
    ss << "       action, resource, details, transaction_id,\n";
    ss << "       transaction_hash, metadata_json\n";
    ss << "FROM audit_entries\n";

    bool has_where = false;
    auto add_where = [&]() {
        if (!has_where) {
            ss << "WHERE ";
            has_where = true;
        } else {
            ss << "  AND ";
        }
    };

    if (!query.severity_filter.empty()) {
        add_where();
        ss << "severity IN (";
        for (size_t i = 0; i < query.severity_filter.size(); i++) {
            ss << "'" << severity_to_string(query.severity_filter[i]) << "'";
            if (i < query.severity_filter.size() - 1) ss << ", ";
        }
        ss << ")\n";
    }

    if (!query.category_filter.empty()) {
        add_where();
        ss << "category IN (";
        for (size_t i = 0; i < query.category_filter.size(); i++) {
            ss << "'" << category_to_string(query.category_filter[i]) << "'";
            if (i < query.category_filter.size() - 1) ss << ", ";
        }
        ss << ")\n";
    }

    if (!query.actor_filter.empty()) {
        add_where();
        ss << "actor = '" << escape_sql(query.actor_filter) << "'\n";
    }

    if (!query.resource_filter.empty()) {
        add_where();
        ss << "resource = '" << escape_sql(query.resource_filter) << "'\n";
    }

    if (!query.transaction_id_filter.empty()) {
        add_where();
        ss << "transaction_id = '" << escape_sql(query.transaction_id_filter) << "'\n";
    }

    ss << "ORDER BY timestamp_iso8601 ASC\n";
    ss << "LIMIT " << query.limit << " OFFSET " << query.offset << ";\n";

    return ss.str();
}

// ---- Export Formats ----

std::string AuditPersistenceAdapter::export_to_sql(
    const std::vector<SignedAuditEntry> & entries) const {
    std::stringstream ss;
    ss << "-- GGNuCash Audit Trail SQL Export\n";
    ss << "-- Generated: " << []() {
        auto now = std::chrono::system_clock::now();
        auto t = std::chrono::system_clock::to_time_t(now);
        std::stringstream ts;
        ts << std::put_time(std::gmtime(&t), "%Y-%m-%dT%H:%M:%SZ");
        return ts.str();
    }() << "\n";
    ss << "-- Entries: " << entries.size() << "\n\n";

    ss << "BEGIN TRANSACTION;\n\n";
    ss << generate_schema_sql() << "\n\n";

    auto serialized = serialize_batch(entries);
    if (!serialized.empty()) {
        ss << generate_batch_insert_sql(serialized) << "\n";
    }

    ss << "COMMIT;\n";
    return ss.str();
}

std::string AuditPersistenceAdapter::export_to_structured_text(
    const std::vector<SignedAuditEntry> & entries,
    const std::string & report_title) const {
    std::stringstream ss;

    // Header
    ss << "================================================================\n";
    ss << "  " << report_title << "\n";
    ss << "================================================================\n\n";

    auto now = std::chrono::system_clock::now();
    auto t = std::chrono::system_clock::to_time_t(now);
    ss << "Generated: " << std::put_time(std::gmtime(&t), "%Y-%m-%d %H:%M:%S UTC") << "\n";
    ss << "Total Entries: " << entries.size() << "\n";
    ss << "Compliance: SOX Section 302/404, FIC Act Section 29\n\n";

    ss << "----------------------------------------------------------------\n";

    // Summary statistics
    std::map<std::string, uint64_t> by_severity;
    std::map<std::string, uint64_t> by_category;
    for (const auto & entry : entries) {
        by_severity[severity_to_string(entry.severity)]++;
        by_category[category_to_string(entry.category)]++;
    }

    ss << "SEVERITY BREAKDOWN:\n";
    for (const auto & kv : by_severity) {
        ss << "  " << kv.first << ": " << kv.second << "\n";
    }

    ss << "\nCATEGORY BREAKDOWN:\n";
    for (const auto & kv : by_category) {
        ss << "  " << kv.first << ": " << kv.second << "\n";
    }

    ss << "\n----------------------------------------------------------------\n";
    ss << "DETAILED ENTRIES:\n";
    ss << "----------------------------------------------------------------\n\n";

    for (size_t i = 0; i < entries.size(); i++) {
        const auto & e = entries[i];
        ss << "Entry #" << (i + 1) << ": " << e.entry_id << "\n";
        ss << "  Timestamp: " << e.timestamp_iso8601 << "\n";
        ss << "  Severity:  " << severity_to_string(e.severity) << "\n";
        ss << "  Category:  " << category_to_string(e.category) << "\n";
        ss << "  Actor:     " << e.actor << "\n";
        ss << "  Action:    " << e.action << "\n";
        ss << "  Resource:  " << e.resource << "\n";
        if (!e.details.empty()) {
            ss << "  Details:   " << e.details << "\n";
        }
        if (!e.transaction_id.empty()) {
            ss << "  Tx ID:     " << e.transaction_id << "\n";
            ss << "  Tx Hash:   " << e.transaction_hash << "\n";
        }
        ss << "  Hash:      " << e.entry_hash << "\n";
        ss << "  Prev Hash: " << e.previous_entry_hash << "\n";
        ss << "  Signature: " << e.signature << "\n";
        if (!e.metadata.empty()) {
            ss << "  Metadata:\n";
            for (const auto & kv : e.metadata) {
                ss << "    " << kv.first << ": " << kv.second << "\n";
            }
        }
        ss << "\n";
    }

    ss << "================================================================\n";
    ss << "  END OF REPORT\n";
    ss << "================================================================\n";

    return ss.str();
}

// ---- Statistics ----

AuditPersistenceStats AuditPersistenceAdapter::get_stats() const {
    std::lock_guard<std::mutex> lock(stats_mutex_);
    return stats_;
}

// ---- SQL Helpers ----

std::string AuditPersistenceAdapter::escape_sql(const std::string & str) const {
    std::string result;
    result.reserve(str.size());
    for (char c : str) {
        if (c == '\'') {
            result += "''";
        } else {
            result += c;
        }
    }
    return result;
}

std::string AuditPersistenceAdapter::severity_to_sql(AuditSeverity severity) const {
    return severity_to_string(severity);
}

std::string AuditPersistenceAdapter::category_to_sql(AuditCategory category) const {
    return category_to_string(category);
}

AuditSeverity AuditPersistenceAdapter::sql_to_severity(const std::string & str) const {
    if (str == "INFO")     return AuditSeverity::INFO;
    if (str == "WARNING")  return AuditSeverity::WARNING;
    if (str == "CRITICAL") return AuditSeverity::CRITICAL;
    if (str == "ALERT")    return AuditSeverity::ALERT;
    return AuditSeverity::INFO;
}

AuditCategory AuditPersistenceAdapter::sql_to_category(const std::string & str) const {
    if (str == "TRANSACTION")          return AuditCategory::TRANSACTION;
    if (str == "ACCOUNT_MODIFICATION") return AuditCategory::ACCOUNT_MODIFICATION;
    if (str == "ACCESS_CONTROL")       return AuditCategory::ACCESS_CONTROL;
    if (str == "CONFIGURATION_CHANGE") return AuditCategory::CONFIGURATION_CHANGE;
    if (str == "COMPLIANCE_EVENT")     return AuditCategory::COMPLIANCE_EVENT;
    if (str == "TAMPER_DETECTION")     return AuditCategory::TAMPER_DETECTION;
    if (str == "SYSTEM_EVENT")         return AuditCategory::SYSTEM_EVENT;
    return AuditCategory::SYSTEM_EVENT;
}

} // namespace audit
} // namespace ggnucash
